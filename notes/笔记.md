# 基础回顾
##   生命周期
      beforeCreate：初始化 注入和校验
      created：可以访问到data ，props成员vue创建完毕
      beforeMount：挂载DOM之前执行的，无法获取新元素的内容
      mounted：可以访问新的DOM结构中的内容
      beforeUpdate：再次修改data成员的时候触发，进行新旧DOM的对比，把差异重新渲染到浏览器中
      updated：获取最新的html结构
      beforeDestory：销毁之前调用，做清理工作
      destoryed：最后调用destoryed进行销毁
##   语法
      差值表达式 {{msg}}
      指令
      计算属性和监听器
      class和style绑定
      条件和列表渲染
      表单输入绑定
      组件：可复用vue实例
      插槽：router-view
      插件
      混入：多个组件有相同的属性可以用混入
      深入响应式原理
      不同版本的vue

# vue-router
##   基本使用
      注册路由插件：Vue.use(VueRouter)
      定义路由规则
      创建路由对象
      导出路由对象
##   hash和history模式
###      区别
           表现形式：路由中带不带#，参数?id=，history模式需要服务端支持
           原理：hash模式是基于锚点，以及onhashchange实现；History模式是基于HTML5的history API实现的 ，history.pushState(), history,replaceState()
##   实现vue-router
###      原理
###         hash模式
            URL中#后面的内容作为路径地址
            监听hashChange事件
            根据当前路由地址找到对应的组件重新渲染
###         history模式
            根据history.pushState方法改变地址栏
            监听popState事件
            根据当前路由地址找到对应的组件重新渲染
###      vueRouter类图
####         属性
            options:记录构造函数中传入的对象
            data：对象中的curry记录当前路由地址，是响应式的对象
            routeMap：记录路由地址和组件的对应关系
####         方法
            Constructor(options):vueRouter：初始化属性
            _install(vue):void  ：实现vue的插件机制
            init():void：init方法用来调用下面的三个方法
            initEvent():void：注册popState方法，监听浏览器历史的变化
            createRouteMap():void ：初始化routeMap属性，把构造函数传入的路由规则转换成键值对的形式，存储到routeMap中
            initComponents(vue):void：创建router-link和router-view组件

## vue响应式原理
###    数据驱动
####      数据响应式
         数据模型仅仅是普通的javaScript对象，当我们修改数据时，视图会进行更新，避免了繁琐的DOM操作，提高开发效率
####      双向绑定
         数据改变，视图改变，视图改变，数据也会随之改变
         我们可以使用v-model在表单元素上进行双向数据绑定
####      数据驱动
         开发过程中仅需要关注数据本身，不需要关心数据是如何渲染到视图的
###   响应式核心
      vue2.x使用Objeat.defineProperty()，把data中的所有属性转为getter/setter
      使用proxy代理直接监听属性而非对象，不支持IE浏览器
###   发订阅者模式
####      发布者
         执行完某个任务就向信号中心发布一个信号
####      订阅者
         从信号中心订阅这个信号，从而知道自己什么时候开始执行
####      信号中心
###   观察者模式
####      观察者（订阅者）--  Watcher
         Update：当事件发生时，具体要做的事情
####      目标（发布者）--  Dep
         subs数组：存储存储所有的观察者
         addSub：添加观察者
         notify：当事件发生时，调用所有观察者的update方法
###   响应式原理
####      vue
#####         功能
            负责初始化的参数（选项）
            负责把data中的选项注入到vue实例中，转换成getter/setter
            负责监听observe监听data中所有属性变化，更新视图
            负责调用compiler解析指令/差值表达式，在视图中转换成数据
#####        vue类结构
            属性
               options
               el
               data
            方法
               _proxyData
###        代码
         ```javascript
            class Vue {
                constructor (options) {
                    // 1. 通过属性保存选项的数据
                    this.$options = options || {}
                    this.$data = options.data || {}
                    this.$el = typeof options.el === 'string' ? document.querySelector(options.el) : options.el
                    // 2. 把data中的成员转换成getter和setter，注入到vue实例中
                    this._proxyData(this.$data)
                    // 3. 调用observer对象，监听数据的变化
                    new Observer(this.$data)
                    // 4. 调用compiler对象，解析指令和差值表达式
                    new Compiler(this)
                }
                _proxyData (data) {
                    // 遍历data中的所有属性
                    Object.keys(data).forEach(key => {
                    // 把data的属性注入到vue实例中
                    Object.defineProperty(this, key, {
                        enumerable: true,
                        configurable: true,
                        get () {
                        return data[key]
                        },
                        set (newValue) {
                        if (newValue === data[key]) {
                            return
                        }
                        data[key] = newValue
                        }
                    })
                    })
                }
            }
         ```
##      observe
         功能
            把data中的数据转换成响应式数据
            data中某个属性也是对象，把该属性也转换成响应式数据
            数据变化发送通知
         结构
            walk(data)
            defineReactive(data, key, value)
         代码
         (```)
            class Observer {
                constructor (data) {
                    this.walk(data)
                }
                walk (data) {
                    // 1. 判断data是否是对象
                    if (!data || typeof data !== 'object') {
                    return
                    }
                    // 2. 遍历data对象的所有属性
                    Object.keys(data).forEach(key => {
                    this.defineReactive(data, key, data[key])
                    })
                }
                defineReactive (obj, key, val) {
                    let that = this
                    // 负责收集依赖，并发送通知
                    let dep = new Dep()
                    // 如果val是对象，把val内部的属性转换成响应式数据
                    this.walk(val)
                    Object.defineProperty(obj, key, {
                    enumerable: true,
                    configurable: true,
                    get () {
                        // 收集依赖
                        Dep.target && dep.addSub(Dep.target)
                        return val
                    },
                    set (newValue) {
                        if (newValue === val) {
                        return
                        }
                        val = newValue
                        that.walk(newValue)
                        // 发送通知
                        dep.notify()
                    }
                    })
                }
            }
         (```)
      compile
         功能
            负责编译模版，解析指令/差值表达式
            负责页面的首次渲染
            当数据发生变化后重新渲染视图
         结构
            属性
               el
               vm
            方法
               compile(el)：遍历传过来的el，如果是文本节点解析差值表达式，如果是元素节点解析指令
               isElementNode(node):判断是否是元素节点
               isTextNode(node):判断是否是文本节点
               isDirective(attrName):判断当前属性是否是指令
               compileText(node):如果是文本节点解析差值表达式
               compileElement(node):如果是元素节点解析指令
         代码
      dep
         功能
            收集依赖，添加观察者（watcher）
            通知所有观察者
         结构
            属性
               subs
            方法
               addSubs(sub)：添加观察者sub存在并且sub有update属性，把sub添加到subs（观察者）数组中
         代码
      watcher
         功能
            当数据发生变化触发依赖，dep通知所有的依赖更新视图
            自身实例化的时候往dep对象中添加自己
         结构
            属性
               vm:vue实例
               key：data中的属性名
               cb：回调函数负责更新视图
            方法
               update()：当数据发生变化时更新视图
         代码

Virtual DOM原理
   概念
      Virtual Dom 是由普通的JavaScript的对象来描述DOM对象，因为不是真实的DOM对象，所以称为Virtual Dom（虚拟DOM）
   为什么使用Vritual Dom 
      手动操作DOM比较麻烦，还需要考虑浏览器兼容性问题，虽然有jQuery等简化DOM操作，但是随着项目的复杂DOM操作复杂提升
      为了简化DOM的复杂操作与事出现了各种MVVM，框架，MVVM框架解决了视图和状态的同步问题
      为了简化视图的操作我们可以使用模版引擎，但是模版引擎没有解决跟踪状态的问题，于是Virtual Dom 出现了
      Vritual Dom 的好处是当状态改变时不需要立即更新DOM，只需要创建一个虚拟树来描述DOM，Vritual Dom内部将弄清楚如何让有效（diff）的更新DOM
      虚拟DOM可以维护程序放入状态，跟踪上一次的状态
      通过比较前后两次状态的差异更新真实DOM
   作用
      维护视图和状态的关系
      复杂视图情况下提升渲染性能
      除了渲染DOM外，还可以实现SSR（Nuxt.js/Next.js）,原生应用（Weex/React Native），小程序（mpvue/uni-app）等
   Virtual DOM库
      Snabbdom
         介绍
            Vue2.x内部使用的Virtual DOM就是改造的Snabbdom
               大约200 SLOC 
               通过模块可扩展
               源码使用TypeScript开发
               最快的Virtual DOM之一
         核心功能
            init()是一个高阶函数返回patch()函数
            h() 返回虚拟节点VNode
            thuck()一种优化策略，可以处理不可变数据时使用
         模块
            attrbutes
               设置DOM元素的属性，使用setAttribute()
               处理布尔类型的属性
            props
               和attributes模块相似，设置DOM元素的属性，element[attr] = value
               不处理布尔类型的属性
            class
               切换类样式
               注意：给元素设置类样式的通过esl选择器
            dataset
               设置data-*的自定义属性
            eventlisteners
               注册和移除事件
            style
               设置行内样式，支持动画
               delayed/remove/destory
         核心
            使用h()函数创建javascript对象(Vnode)描述真实DOM
            init()设置模块，创建patch()
            patch()比较新旧两个Vnode
            把变化的内容更新到真实DOM树上
         h()
            h()函数最早见于hyperscript，使用javascript创建超文本
            Snabbdom中的h()函数不是用来创建文本，而是创建Vnode
         函数重载
            参数个数或类型不同的函数
            JavaScript中没有重载的概念
            typescript 中有重载，不过重载的实现还是通过代码调整参数
         vnode()函数:vnode函数用于创建虚拟节点
         snabbdom patch整体执行过程
            patch(oldVnode, newVnode)
            打补丁，把新节点中变化的内容渲染到真实DOM，最后返回新节点作为下一次出炉的旧节点
            对比新旧VNode是否相同（节点的key和sel相同）
            如果不是相同节点，删除之前的内容，重新渲染
            如果是相同节点，再判断新的VNode是否有test，如果有并且和oldVnode的text不同，直接更新文本内容
            如果新的VNode有children，判断子节点是否有变化，判断子节点的过程使用的是diff算法
            diff算法只进行同层级比较
         init()
            初始化转换虚拟节点的api
            把传入的所有模块的钩子函数，统一存储到cbs对象中
            最终构建的cbs对象的形式cbs = {create: [fn1, fn2], update: [fn1, fn2], ...}
            init内部返回patch函数，把VNode渲染成真实DOM，并返回vnode
            emptyNodeAt(elm: Element)
            createRmCb(childElm:Node, listeners: number)
            createElm(vnode: VNode, insertedVnodeQueue: VNodeQueue)
            addVnodes()
            invokeDestroyHook(vnode:VNode)
            removeVnodes()
            updateChildren()
            patchVnode(oldVnode:VNode, vnode: VNode,  insertedVnodeQueue: VNodeQueue)
         patch()
            对比新旧vnode返回一个vnode，作为下一次对比的旧节点
            createElm()函数
            触发用户钩子函数init
            把vnode转换成DOM对象，存储到vnode.elm中（注意：没有渲染到页面）
            sel是！创建注释节点
            sel不为空：创建对应的DOM对象；触发模块的钩子函数create；创建所有节点对应的DOM对象；触发用户的钩子函数create；如果vnode有insert钩子函数，追加到队列
            sel为空：穿件文本节点
            返回vnode.elm
         removeVnode()批量删除节点
         addVnode()批量添加节点
         patchVnode()
            触发prepatch钩子函数
            触发update钩子函数
            新节点有text属性，且不等于旧节点的text属性
               如果老节点有children，移除老节点children对应的DOM元素
               设置新节点对应DOM元素的textContent
            新老节点都有children，且不相等
               调用updateChildren()
               对比节点，并且更新子节点的差异
            只有新节点有children属性
               如果老节点有text属性，清空对应DOM元素的textContent
               添加所有子节点
            只有老节点有children属性
               移除所有的老节点 
            只有老节点有text属性
               清空对用DOM元素的textContent
            触发postpatch钩子函
